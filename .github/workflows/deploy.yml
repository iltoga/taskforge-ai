name: Deploy taskforge-ai to VPS using SSH and GitHub Actions

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-taskforge-ai
      cancel-in-progress: true
    env:
      DOCKER_BUILDKIT: 1

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e

            echo "ğŸš€  Starting deployment â€¦"
            REPO_DIR="$HOME/.docker/taskforge-ai"
            echo "ğŸ“  Repository directory: $REPO_DIR"

            if [ ! -d "$REPO_DIR" ]; then
              echo "âŒ  Repository directory does not exist, aborting."
              exit 1
            fi

            cd "$REPO_DIR"
            echo "ğŸ“‚  Working directory: $(pwd)"

            echo "ğŸ”—  Ensuring correct Git remote â€¦"
            git remote set-url origin git@github.com-deploy-taskforge-ai:iltoga/taskforge-ai.git

            OLD_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo none)
            echo "ğŸ“Š  Current commit: $OLD_COMMIT"

            echo "ğŸ“¥  Fetching latest changes â€¦"
            git fetch --all

            echo "ğŸ”„  Switching to main branch â€¦"
            git checkout main

            echo "ğŸ³  Ensuring no Docker containers are interfering..."
            docker compose down --remove-orphans || echo "âš ï¸  No containers to stop"

            echo "ğŸ§¹  Resetting local state â€¦"
            git reset --hard origin/main

            # Safely clean only untracked files that won't interfere with operations
            echo "ğŸ§¹  Cleaning safe untracked files..."
            git clean -f || echo "âš ï¸  Some files couldn't be cleaned, continuing..."

            echo "â¬‡ï¸  Pulling latest commits â€¦"
            git pull origin main

            NEW_COMMIT=$(git rev-parse HEAD)
            echo "ğŸ“Š  New commit: $NEW_COMMIT"

            echo "ğŸ”  Detecting package-file changes â€¦"
            PACKAGE_CHANGED=false
            if [ "$OLD_COMMIT" != none ] && [ "$OLD_COMMIT" != "$NEW_COMMIT" ]; then
              if git diff --name-only $OLD_COMMIT $NEW_COMMIT | grep -E '(package\.json|package-lock\.json)' >/dev/null; then
                PACKAGE_CHANGED=true
                echo "ğŸ“¦  package.json changed â€” full dependency rebuild needed."
              else
                echo "ğŸ“¦  package.json unchanged â€” cached dependencies will be reused."
              fi
            fi

            echo "âš™ï¸  Exporting environment variables from .env â€¦"
            if [ -f .env ]; then
              set -a
              source .env
              set +a
              echo "âœ…  .env variables loaded."
            else
              echo "âŒ  .env not found, aborting."
              exit 1
            fi

            export GIT_COMMIT_SHA="$NEW_COMMIT"
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            echo "ğŸ—ï¸  Building Docker images â€¦"
            if [ "$PACKAGE_CHANGED" = false ] && [ "$OLD_COMMIT" != none ]; then
              echo "âš¡  Fast rebuild with cache."
              docker compose build db
              docker compose build \
                --build-arg GIT_COMMIT_SHA="$GIT_COMMIT_SHA" \
                taskforge-ai
            else
              echo "ğŸ”„  Full rebuild."
              if [ "$PACKAGE_CHANGED" = true ]; then
                echo "ğŸ§¹  Pruning old dependency layers â€¦"
                docker image prune -f --filter "label=stage=deps" || true
              fi
              docker compose build db
              docker compose build \
                --build-arg GIT_COMMIT_SHA="$GIT_COMMIT_SHA" \
                --no-cache \
                taskforge-ai
            fi

            echo "â¸ï¸  Stopping old application container â€¦"
            docker compose stop taskforge-ai || true

            echo "ğŸ—„ï¸  Starting (or ensuring) database container â€¦"
            docker compose up -d db

            echo "â³  Waiting for database to accept connections â€¦"
            TIMEOUT=60
            while [ $TIMEOUT -gt 0 ]; do
              if docker compose exec -T db pg_isready -U "$DB_USER" -d "$DB_NAME" >/dev/null 2>&1; then
                echo "âœ…  Database is ready."
                break
              fi
              echo "â³  Still waiting â€¦ ($TIMEOUT s left)"
              sleep 2
              TIMEOUT=$((TIMEOUT-2))
            done
            if [ $TIMEOUT -le 0 ]; then
              echo "âŒ  Database failed to start in time."
              docker compose logs db
              exit 1
            fi

            echo "ğŸ—‘ï¸  Removing old app container (if any) â€¦"
            docker compose rm -f taskforge-ai || true

            echo "ğŸš€  Starting new application container â€¦"
            docker compose up -d --remove-orphans taskforge-ai

            echo "ğŸ”  Verifying container status â€¦"
            sleep 10
            if docker compose ps taskforge-ai | grep -q "Up"; then
              echo "âœ…  taskforge-ai container is up."
            else
              echo "âŒ  taskforge-ai container failed to start."
              docker compose logs taskforge-ai
              exit 1
            fi

            echo "ğŸ¥  Running health check on http://localhost:3000 â€¦"
            sleep 10
            if curl -f http://localhost:3000 >/dev/null 2>&1; then
              echo "âœ…  Health check passed."
            else
              echo "âš ï¸  Health check failed, but container is running."
            fi

            echo "ğŸ§¹  Cleaning up unused containers & dangling images â€¦"
            docker container prune -f
            docker image prune -f --filter "dangling=true"

            echo "ğŸ“Š  Final container status:"
            docker compose ps

            echo "ğŸ‰  Deployment complete!"
