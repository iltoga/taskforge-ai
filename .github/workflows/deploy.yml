name: Deploy taskforge-ai to VPS using SSH and github Actions
description: |
  This workflow deploys the taskforge-ai application to a VPS using SSH and Docker.
  It builds the Docker images with aggressive caching, pulls the latest changes from the repository,
  and restarts the application containers with minimal downtime.
  This workflow requires:
     * the SSH_PRIVATE_KEY, VPS_HOST, and VPS_USERNAME secrets to be set in the repository settings and
     * the .env file to be present in the repository root.
     * a linux server with Docker and Docker Compose installed.

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DOCKER_BUILDKIT: 1

    steps:
      - name: Add GitHub.com to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: SSH into VPS and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e  # Exit on any error

            echo "ğŸš€ Starting optimized deployment process..."

            # Check and setup repository
            REPO_DIR="$HOME/.docker/taskforge-ai"
            echo "Repository directory: $REPO_DIR"

            # Navigate to repository directory
            if [ ! -d "$REPO_DIR" ]; then
              echo "âŒ Error: Repository directory does not exist: $REPO_DIR"
              exit 1
            fi

            cd "$REPO_DIR"
            echo "ğŸ“ Current directory: $(pwd)"

            # Ensure remote URL is correct using the custom SSH configuration
            echo "ğŸ”— Setting git remote URL..."
            git remote set-url origin git@github.com-deploy-taskforge-ai:iltoga/taskforge-ai.git

            # Get current commit before update
            OLD_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "none")

            # Ensure we're on the main branch and clean any local changes
            echo "ğŸ“¥ Fetching latest changes..."
            git fetch --all

            echo "ğŸ”„ Switching to main branch..."
            git checkout main

            echo "ğŸ§¹ Resetting to latest remote state..."
            git reset --hard origin/main
            git clean -fd || true

            echo "â¬‡ï¸ Pulling latest changes..."
            git pull origin main

            # Get new commit SHA
            NEW_COMMIT=$(git rev-parse HEAD)
            echo "ğŸ“Š Old commit: $OLD_COMMIT"
            echo "ğŸ“Š New commit: $NEW_COMMIT"

            # Check if package files changed to determine rebuild strategy
            PACKAGE_CHANGED=false
            if [ "$OLD_COMMIT" != "none" ] && [ "$OLD_COMMIT" != "$NEW_COMMIT" ]; then
              if git diff --name-only $OLD_COMMIT $NEW_COMMIT | grep -E "(package\.json|package-lock\.json)" > /dev/null; then
                PACKAGE_CHANGED=true
                echo "ğŸ“¦ Package files changed - will rebuild dependencies"
              else
                echo "ğŸ“¦ Package files unchanged - using cached dependencies"
              fi
            fi

            # Enable Docker BuildKit for advanced caching
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1

            # Source environment variables if available
            if [ -f .env ]; then
              echo "ğŸ”§ Loading environment variables from .env..."
              source .env
            else
              echo "âš ï¸ Warning: .env file not found"
              exit 1
            fi

            # Set git commit for cache busting
            export GIT_COMMIT_SHA=$NEW_COMMIT

            echo "ğŸ—ï¸ Building containers with aggressive caching..."

            # Strategy 1: If only source code changed, use cache-from for faster builds
            if [ "$PACKAGE_CHANGED" = false ] && [ "$OLD_COMMIT" != "none" ]; then
              echo "âš¡ Using cached layers for dependencies..."

              # Build database container (rarely changes)
              echo "ğŸ—„ï¸ Building database container..."
              docker compose build db

              # Build app with maximum cache utilization
              echo "ğŸš€ Building application with cache..."
              docker compose build \
                --build-arg GIT_COMMIT_SHA="$NEW_COMMIT" \
                --build-arg OPENAI_API_KEY="$OPENAI_API_KEY" \
                taskforge-ai

            else
              echo "ğŸ”„ Full rebuild required..."

              # Clean up old images if package changed to avoid conflicts
              if [ "$PACKAGE_CHANGED" = true ]; then
                echo "ğŸ§¹ Cleaning up old dependency caches..."
                docker image prune -f --filter "label=stage=deps" || true
              fi

              # Build database container
              echo "ğŸ—„ï¸ Building database container..."
              docker compose build db

              # Build application with fresh dependencies
              echo "ğŸš€ Building application..."
              docker compose build \
                --build-arg GIT_COMMIT_SHA="$NEW_COMMIT" \
                --build-arg OPENAI_API_KEY="$OPENAI_API_KEY" \
                --no-cache \
                taskforge-ai
            fi

            # Rolling update deployment for minimal downtime
            echo "ğŸ”„ Performing rolling update..."

            # Stop old container gracefully
            echo "â¸ï¸ Stopping old application container..."
            docker compose stop taskforge-ai || true

            # Start database if not running
            echo "ğŸ—„ï¸ Ensuring database is running..."
            docker compose up -d db

            # Wait for database with timeout
            echo "â³ Waiting for database to be ready..."
            TIMEOUT=60
            while [ $TIMEOUT -gt 0 ]; do
              if docker compose exec -T db pg_isready -U "$DB_USER" -d "$DB_NAME" >/dev/null 2>&1; then
                echo "âœ… Database is ready!"
                break
              fi
              echo "â³ Database not ready, waiting... ($TIMEOUT seconds left)"
              sleep 2
              TIMEOUT=$((TIMEOUT - 2))
            done

            if [ $TIMEOUT -le 0 ]; then
              echo "âŒ Database failed to start in time"
              docker compose logs db
              exit 1
            fi

            # Start new application container
            echo "ğŸš€ Starting new application container..."
            docker compose up -d taskforge-ai

            # Verify deployment with extended timeout
            echo "ğŸ” Verifying deployment..."
            VERIFY_TIMEOUT=60
            while [ $VERIFY_TIMEOUT -gt 0 ]; do
              if docker compose ps taskforge-ai | grep -q "Up"; then
                echo "âœ… Container is running successfully"
                break
              fi
              echo "â³ Container starting... ($VERIFY_TIMEOUT seconds left)"
              sleep 2
              VERIFY_TIMEOUT=$((VERIFY_TIMEOUT - 2))
            done

            if [ $VERIFY_TIMEOUT -le 0 ]; then
              echo "âŒ Container failed to start"
              docker compose logs taskforge-ai
              exit 1
            fi

            # Health check
            echo "ğŸ¥ Performing health check..."
            sleep 10
            if curl -f http://localhost:3000 >/dev/null 2>&1; then
              echo "âœ… Application is responding to health checks"
            else
              echo "âš ï¸ Health check failed, but container is running"
            fi

            # Clean up only unused images and containers (keep cache)
            echo "ğŸ§¹ Cleaning up unused resources..."
            docker container prune -f
            docker image prune -f --filter "dangling=true"

            # Show final status
            echo "ğŸ“Š Final container status:"
            docker compose ps

            echo "ğŸ‰ Deployment completed successfully!"
            echo "ğŸ“Š New version deployed: $NEW_COMMIT"
